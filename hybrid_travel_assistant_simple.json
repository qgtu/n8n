{
  "name": "Hybrid Travel Assistant - Simple Form",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "travel-form",
        "responseMode": "onReceived",
        "options": {
          "allowedOrigins": "*"
        }
      },
      "id": "webhook-node",
      "name": "Webhook",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1.1,
      "position": [200, 300],
      "webhookId": "travel-form-simple"
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{ $json.body?.message }}",
              "operation": "isNotEmpty"
            }
          ]
        }
      },
      "id": "validate-node",
      "name": "Validate Input",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [400, 300]
    },
    {
      "parameters": {
        "jsCode": "return {\n  intent: 'validation_error',\n  response: 'Vui l√≤ng nh·∫≠p n·ªôi dung y√™u c·∫ßu (t·ªëi thi·ªÉu 3 k√Ω t·ª±). V√≠ d·ª•: \"th·ªùi ti·∫øt H√† N·ªôi\"',\n  type: 'error'\n};"
      },
      "id": "validation-error-node",
      "name": "Validation_Error",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 500]
    },
    {
      "parameters": {
        "jsCode": "const message = ($json.body?.message || '').toLowerCase().trim();\n\nconst rules = [\n  { intent: 'get_weather', keywords: ['th·ªùi ti·∫øt', 'weather', 'tr·ªùi', 'n·∫Øng', 'm∆∞a'] },\n  { intent: 'search_hotel', keywords: ['kh√°ch s·∫°n', 'hotel', 'ch·ªó ·ªü'] },\n  { intent: 'get_attraction_info', keywords: ['ƒëi·ªÉm tham quan', 'attraction', 'du l·ªãch'] }\n];\n\nconst matched = rules.find(r => r.keywords.some(kw => message.includes(kw)));\n\nreturn {\n  message,\n  message_original: $json.body?.message || '',\n  intent: matched?.intent || 'unknown',\n  needs_ai: !matched\n};"
      },
      "id": "rule-intent-node",
      "name": "Rule-Based Intent Detect",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [600, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.needs_ai }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-ai-node",
      "name": "AI Fallback Check",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [800, 300]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.groq.com/openai/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpHeaderAuth",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"model\": \"llama-3.1-8b-instant\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Ph√¢n lo·∫°i intent. Ch·ªâ tr·∫£ v·ªÅ JSON: {\\\"intent\\\": \\\"get_weather\\\" | \\\"search_hotel\\\" | \\\"get_attraction_info\\\" | \\\"unknown\\\"}\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{ $json.message }}\"\n    }\n  ],\n  \"temperature\": 0.1,\n  \"max_tokens\": 50\n}",
        "options": {
          "timeout": 10000
        }
      },
      "id": "ai-agent-node",
      "name": "AI Agent (Fallback ONLY)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1000, 100],
      "credentials": {
        "httpHeaderAuth": {
          "id": "GROQ_API_CREDENTIAL",
          "name": "Groq API Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const content = $json.choices?.[0]?.message?.content || '{}';\nlet parsed = {};\ntry { parsed = JSON.parse(content); } catch(e) {}\n\nreturn {\n  intent: parsed.intent || 'unknown',\n  message: $('AI Fallback Check').item.json.message,\n  message_original: $('AI Fallback Check').item.json.message_original\n};"
      },
      "id": "parse-ai-node",
      "name": "Parse AI Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1100, 100]
    },
    {
      "parameters": {
        "jsCode": "const message = $json.message || '';\n\nconst locationMap = {\n  'h√† n·ªôi': 'Hanoi', 'hanoi': 'Hanoi',\n  'ƒë√† n·∫µng': 'Da Nang', 'da nang': 'Da Nang',\n  's√†i g√≤n': 'Ho Chi Minh', 'saigon': 'Ho Chi Minh',\n  'b·∫Øc kinh': 'Beijing', 'beijing': 'Beijing',\n  'tokyo': 'Tokyo', 'paris': 'Paris', 'london': 'London',\n  'new york': 'New York', 'singapore': 'Singapore'\n};\n\nconst location = Object.entries(locationMap).find(([k]) => message.includes(k))?.[1] || null;\n\nlet timeIntent = 'today';\nif (message.includes('ng√†y mai') || message.includes('mai') || message.includes('tomorrow')) timeIntent = 'tomorrow';\nelse if (message.includes('m·ªët')) timeIntent = 'day_after';\nelse if (message.match(/(\\d+)\\s*(ng√†y|days?)\\s*(t·ªõi|n·ªØa|sau)/)) timeIntent = 'n_days';\nelse if (message.includes('v√†i ng√†y') || message.includes('m·∫•y ng√†y')) timeIntent = 'few_days';\nelse if (message.includes('cu·ªëi tu·∫ßn')) timeIntent = 'weekend';\nelse if (message.includes('tu·∫ßn n√†y')) timeIntent = 'this_week';\nelse if (message.match(/(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/)) timeIntent = 'specific_date';\n\nreturn {\n  intent: $json.intent || 'unknown',\n  entities: { location },\n  timeIntent,\n  message,\n  message_original: $json.message_original || message\n};"
      },
      "id": "extract-location-node",
      "name": "Extract Location & Time Intent",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1200, 300]
    },
    {
      "parameters": {
        "url": "https://api.weatherapi.com/v1/current.json",
        "authentication": "none",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "key",
              "value": "52c2f536877444ec8a0165526260501"
            },
            {
              "name": "q",
              "value": "={{ $json.entities.location }}"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "timezone-resolver-node",
      "name": "Phase 1: Timezone Resolver",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1400, 300]
    },
    {
      "parameters": {
        "jsCode": "const prevData = $('Extract Location & Time Intent').item.json;\nconst message = prevData.message || '';\nconst timeIntent = prevData.timeIntent || 'today';\n\nconst locationData = $json.location || {};\nconst localtime = locationData.localtime || new Date().toISOString().replace('T', ' ').substr(0, 16);\nconst local_date = localtime.split(' ')[0];\nconst tz = locationData.tz_id || 'UTC';\n\nconst parseDate = (dateStr) => {\n  const [y, m, d] = dateStr.split('-').map(Number);\n  return new Date(y, m - 1, d);\n};\n\nconst clamp = (val, min, max) => Math.max(min, Math.min(max, val));\n\nconst today = parseDate(local_date);\nconst todayWeekday = today.getDay();\n\nlet mode = 'current';\nlet days = 1;\n\nif (timeIntent === 'today') {\n  mode = 'current';\n  days = 1;\n} else if (timeIntent === 'tomorrow') {\n  mode = 'forecast';\n  days = 2;\n} else if (timeIntent === 'day_after') {\n  mode = 'forecast';\n  days = 3;\n} else if (timeIntent === 'n_days') {\n  const match = message.match(/(\\d+)\\s*(ng√†y|days?)/);\n  const n = parseInt(match[1]);\n  mode = 'forecast';\n  days = clamp(n + 1, 1, 10);\n} else if (timeIntent === 'few_days') {\n  mode = 'forecast';\n  days = 4;\n} else if (timeIntent === 'weekend') {\n  const WEEKEND_DAYS = [6, 0];\n  const deltas = WEEKEND_DAYS.map(day => {\n    let delta = (day - todayWeekday + 7) % 7;\n    if (delta === 0) delta = 7;\n    return delta;\n  }).sort((a, b) => a - b);\n  const maxDelta = Math.max(...deltas);\n  mode = 'forecast';\n  days = clamp(maxDelta + 1, 1, 10);\n} else if (timeIntent === 'this_week') {\n  const daysToSunday = todayWeekday === 0 ? 0 : (7 - todayWeekday);\n  mode = 'forecast';\n  days = clamp(daysToSunday + 1, 1, 10);\n} else if (timeIntent === 'specific_date') {\n  const datePatterns = [\n    /(\\d{1,2})\\/(\\d{1,2})\\/(\\d{4})/,\n    /(\\d{4})-(\\d{2})-(\\d{2})/\n  ];\n  for (const pattern of datePatterns) {\n    const match = message.match(pattern);\n    if (match) {\n      let parsed;\n      if (pattern.source.startsWith('(\\\\d{4})')) {\n        parsed = match[0];\n      } else {\n        const [_, day, month, year] = match;\n        parsed = `${year}-${month.padStart(2,'0')}-${day.padStart(2,'0')}`;\n      }\n      const targetDate = parseDate(parsed);\n      const diffMs = targetDate - today;\n      const diffDays = Math.ceil(diffMs / 86400000);\n      if (diffDays <= 0) {\n        mode = 'current';\n        days = 1;\n      } else {\n        mode = 'forecast';\n        days = clamp(diffDays + 1, 1, 10);\n      }\n      break;\n    }\n  }\n}\n\nreturn {\n  intent: prevData.intent || 'unknown',\n  entities: { \n    location: prevData.entities.location,\n    weatherMode: { \n      mode, \n      days,\n      timeIntent,\n      targetOffset: mode === 'current' ? 0 : days - 1\n    }\n  },\n  timezone: { tz, local_date, localtime },\n  message: prevData.message,\n  message_original: prevData.message_original\n};"
      },
      "id": "time-calculator-node",
      "name": "Time Intent Calculator",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1600, 300]
    },
    {
      "parameters": {
        "jsCode": "const intent = $json.intent || 'unknown';\nconst entities = $json.entities || {};\n\nconst requirements = {\n  get_weather: ['location'],\n  search_hotel: ['location'],\n  get_attraction_info: ['location']\n};\n\nconst required = requirements[intent] || [];\nconst missing = required.filter(f => !entities[f]);\n\nreturn {\n  ...$json,\n  has_all_fields: missing.length === 0,\n  missing_fields: missing\n};"
      },
      "id": "check-fields-node",
      "name": "Check Required Fields",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1800, 300]
    },
    {
      "parameters": {
        "conditions": {
          "boolean": [
            {
              "value1": "={{ $json.has_all_fields }}",
              "value2": true
            }
          ]
        }
      },
      "id": "check-complete-node",
      "name": "Has_All_Required_Data?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [2000, 300]
    },
    {
      "parameters": {
        "jsCode": "const missing = $json.missing_fields || [];\nconst fieldNames = { location: 'ƒë·ªãa ƒëi·ªÉm', date: 'ng√†y' };\n\nconst question = 'Vui l√≤ng cho bi·∫øt ' + missing.map(f => fieldNames[f] || f).join(', ') + '?';\n\nreturn { response: question, type: 'clarification' };"
      },
      "id": "ask-again-node",
      "name": "H·ªèi l·∫°i User",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2200, 500]
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.intent }}",
                    "rightValue": "get_weather",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  },
                  {
                    "leftValue": "={{ $json.entities.weatherMode.mode }}",
                    "rightValue": "current",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Weather-Current"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.intent }}",
                    "rightValue": "get_weather",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  },
                  {
                    "leftValue": "={{ $json.entities.weatherMode.mode }}",
                    "rightValue": "forecast",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Weather-Forecast"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.intent }}",
                    "rightValue": "search_hotel",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Hotel"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict"
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.intent }}",
                    "rightValue": "get_attraction_info",
                    "operator": {
                      "type": "string",
                      "operation": "equals"
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "Attraction"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "route-tool-node",
      "name": "Route to Tool",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.2,
      "position": [2200, 300]
    },
    {
      "parameters": {
        "url": "https://api.weatherapi.com/v1/forecast.json",
        "authentication": "none",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "key",
              "value": "52c2f536877444ec8a0165526260501"
            },
            {
              "name": "q",
              "value": "={{ $json.entities.location }}"
            },
            {
              "name": "days",
              "value": "1"
            },
            {
              "name": "lang",
              "value": "vi"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "weather-current-node",
      "name": "Weather Current (Today)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2600, 50]
    },
    {
      "parameters": {
        "url": "https://api.weatherapi.com/v1/forecast.json",
        "authentication": "none",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "key",
              "value": "52c2f536877444ec8a0165526260501"
            },
            {
              "name": "q",
              "value": "={{ $json.entities.location }}"
            },
            {
              "name": "days",
              "value": "={{ $json.entities.weatherMode?.days || 2 }}"
            },
            {
              "name": "lang",
              "value": "vi"
            }
          ]
        },
        "options": {
          "timeout": 10000
        }
      },
      "id": "weather-forecast-node",
      "name": "Weather Forecast (Future)",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2600, 150]
    },
    {
      "parameters": {
        "url": "https://serpapi.com/search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpQueryAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "engine",
              "value": "google_hotels"
            },
            {
              "name": "q",
              "value": "={{ $json.entities.location }} hotels"
            },
            {
              "name": "check_in_date",
              "value": "={{ $now.format('yyyy-MM-dd') }}"
            },
            {
              "name": "check_out_date",
              "value": "={{ $now.plus({days: 1}).format('yyyy-MM-dd') }}"
            },
            {
              "name": "currency",
              "value": "VND"
            }
          ]
        },
        "options": {
          "timeout": 15000
        }
      },
      "id": "hotel-tool-node",
      "name": "Hotel Tool",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2400, 300],
      "credentials": {
        "httpQueryAuth": {
          "id": "SERPAPI_CREDENTIAL",
          "name": "SerpAPI Key"
        }
      }
    },
    {
      "parameters": {
        "url": "https://serpapi.com/search",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "httpQueryAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "engine",
              "value": "google"
            },
            {
              "name": "q",
              "value": "={{ $json.entities.location }} ƒëi·ªÉm tham quan du l·ªãch"
            },
            {
              "name": "hl",
              "value": "vi"
            },
            {
              "name": "gl",
              "value": "vn"
            }
          ]
        },
        "options": {
          "timeout": 15000
        }
      },
      "id": "attraction-tool-node",
      "name": "Attraction Tool",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [2400, 500],
      "credentials": {
        "httpQueryAuth": {
          "id": "SERPAPI_CREDENTIAL",
          "name": "SerpAPI Key"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "return {\n  intent: 'unsupported',\n  response: 'T√¥i h·ªó tr·ª£: th·ªùi ti·∫øt, kh√°ch s·∫°n, ƒëi·ªÉm tham quan. V√≠ d·ª•: \"th·ªùi ti·∫øt H√† N·ªôi\"',\n  type: 'error'\n};"
      },
      "id": "unsupported-node",
      "name": "Unsupported_Handler",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2400, 700]
    },
    {
      "parameters": {
        "jsCode": "const data = $json;\nconst intent = $('Route to Tool').item.json.intent || 'unknown';\nconst weatherMode = $('Route to Tool').item.json.entities?.weatherMode || {};\nlet response = '';\n\nif (intent === 'get_weather') {\n  const loc = data.location?.name || 'N/A';\n  const forecastDays = data.forecast?.forecastday || [];\n  const timeIntent = weatherMode.timeIntent || 'today';\n  \n  if (forecastDays.length === 0) {\n    response = 'Kh√¥ng l·∫•y ƒë∆∞·ª£c d·ªØ li·ªáu th·ªùi ti·∫øt';\n  } else {\n    let displayDays = forecastDays;\n    \n    if (timeIntent === 'today' || timeIntent === 'tomorrow' || timeIntent === 'day_after' || timeIntent === 'specific_date') {\n      const offset = weatherMode.targetOffset ?? forecastDays.length - 1;\n      displayDays = [forecastDays[offset] || forecastDays[forecastDays.length - 1]];\n    } else if (timeIntent === 'weekend') {\n      displayDays = forecastDays.filter(d => {\n        const wd = new Date(d.date + 'T00:00:00').getDay();\n        return wd === 6 || wd === 0;\n      });\n    }\n    \n    if (displayDays.length === 1) {\n      const day = displayDays[0];\n      response = `üå§Ô∏è ${loc} (${day.date}): ${day.day.avgtemp_c}¬∞C (${day.day.mintemp_c}-${day.day.maxtemp_c}¬∞C), ${day.day.condition?.text || ''}, m∆∞a ${day.day.daily_chance_of_rain}%`;\n    } else {\n      const dayLabels = ['CN', 'T2', 'T3', 'T4', 'T5', 'T6', 'T7'];\n      const dayLines = displayDays.map(d => {\n        const wd = new Date(d.date + 'T00:00:00').getDay();\n        const label = dayLabels[wd];\n        return `üìÖ ${label} (${d.date.substr(5)}): ${d.day.condition?.text || ''}, ${d.day.mintemp_c}‚Üí${d.day.maxtemp_c}¬∞C, m∆∞a ${d.day.daily_chance_of_rain}%`;\n      }).join('\\n');\n      response = `üå§Ô∏è ${loc} (${displayDays[0].date} ‚Üí ${displayDays[displayDays.length-1].date}):\\n${dayLines}`;\n    }\n  }\n} else if (intent === 'search_hotel') {\n  const hotels = data.properties || [];\n  response = 'üè® Kh√°ch s·∫°n:\\n' + hotels.slice(0,5).map((h,i) => `${i+1}. ${h.name} - ${h.rate_per_night?.lowest || 'N/A'}`).join('\\n');\n} else if (intent === 'get_attraction_info') {\n  const results = data.organic_results || [];\n  response = 'üèõÔ∏è ƒêi·ªÉm tham quan:\\n' + results.slice(0,5).map((r,i) => `${i+1}. ${r.title}`).join('\\n');\n} else {\n  response = data.response || 'Kh√¥ng th·ªÉ x·ª≠ l√Ω.';\n}\n\nreturn { intent, response, type: 'success' };"
      },
      "id": "postprocess-node",
      "name": "Post-Process",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [2800, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ $json }}"
      },
      "id": "final-response-node",
      "name": "Respond",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [3000, 300]
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
            
          }
        ]
      ]
    },
    "Validate Input": {
      "main": [
        [
          {
            "node": "Rule-Based Intent Detect",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Validation_Error",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validation_Error": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Rule-Based Intent Detect": {
      "main": [
        [
          {
            "node": "AI Fallback Check",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Fallback Check": {
      "main": [
        [
          {
            "node": "AI Agent (Fallback ONLY)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Extract Location & Time Intent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent (Fallback ONLY)": {
      "main": [
        [
          {
            "node": "Parse AI Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse AI Response": {
      "main": [
        [
          {
            "node": "Extract Location & Time Intent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Extract Location & Time Intent": {
      "main": [
        [
          {
            "node": "Phase 1: Timezone Resolver",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Phase 1: Timezone Resolver": {
      "main": [
        [
          {
            "node": "Time Intent Calculator",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Time Intent Calculator": {
      "main": [
        [
          {
            "node": "Check Required Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Required Fields": {
      "main": [
        [
          {
            "node": "Has_All_Required_Data?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has_All_Required_Data?": {
      "main": [
        [
          {
            "node": "Route to Tool",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "H·ªèi l·∫°i User",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "H·ªèi l·∫°i User": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Route to Tool": {
      "main": [
        [
          {
            "node": "Weather Current (Today)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Weather Forecast (Future)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Hotel Tool",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Attraction Tool",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Unsupported_Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Weather Current (Today)": {
      "main": [
        [
          {
            "node": "Post-Process",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Weather Forecast (Future)": {
      "main": [
        [
          {
            "node": "Post-Process",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hotel Tool": {
      "main": [
        [
          {
            "node": "Post-Process",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Attraction Tool": {
      "main": [
        [
          {
            "node": "Post-Process",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Unsupported_Handler": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Post-Process": {
      "main": [
        [
          {
            "node": "Respond",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v2"
  },
  "versionId": "simple-hybrid-v2-pro",
  "meta": {
    "instanceId": "simple-hybrid-architecture"
  },
  "id": "HybridTravelAssistantSimple",
  "tags": [
    {
      "name": "hybrid"
    },
    {
      "name": "pro-standard"
    }
  ]
}
